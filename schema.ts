//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           3.1.3
//
//
//       bebopc source:
//           https://github.com/betwixt-labs/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
import { BebopView, BebopRuntimeError, BebopRecord, BebopJson, BebopTypeGuard, Guid, GuidMap } from "bebop";

export const BEBOP_SCHEMA = new Uint8Array ([
3, 3, 0, 0, 0, 85, 115, 101, 114, 0, 2, 0, 5, 0, 0, 0, 2,
110, 97, 109, 101, 0, 245, 255, 255, 255, 0, 1, 117, 105,
100, 0, 245, 255, 255, 255, 0, 2, 67, 111, 109, 109, 97,
110, 100, 84, 121, 112, 101, 0, 4, 0, 251, 255, 255, 255,
0, 4, 0, 0, 0, 6, 72, 69, 76, 76, 79, 0, 0, 1, 0, 0, 0,
83, 69, 83, 83, 73, 79, 78, 95, 67, 82, 69, 65, 84, 69, 0,
0, 2, 0, 0, 0, 83, 69, 83, 83, 73, 79, 78, 95, 74, 79, 73,
78, 0, 0, 3, 0, 0, 0, 83, 69, 83, 83, 73, 79, 78, 95, 73,
78, 70, 79, 0, 0, 4, 0, 0, 0, 83, 69, 83, 83, 73, 79, 78,
95, 71, 69, 84, 0, 0, 5, 0, 0, 0, 83, 79, 78, 71, 95, 83,
72, 79, 87, 0, 0, 10, 0, 0, 0, 67, 111, 109, 109, 97, 110,
100, 0, 2, 0, 5, 0, 0, 0, 3, 116, 121, 112, 101, 0, 1, 0,
0, 0, 0, 1, 117, 115, 101, 114, 0, 0, 0, 0, 0, 0, 2, 100,
97, 116, 97, 0, 245, 255, 255, 255, 0, 3, 0, 0, 0, 0
]);

export interface IUser extends BebopRecord {

  name?: string;

  uid?: string;
}

export class User implements IUser {
  public name?: string;
  public uid?: string;

  constructor(record: IUser) {
    this.name = record.name;
    this.uid = record.uid;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return User.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IUser): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    User.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link User}.
   */
  public static validateCompatibility(record: IUser): void {
    if (record.name !== undefined) {
      BebopTypeGuard.ensureString(record.name)
    }
    if (record.uid !== undefined) {
      BebopTypeGuard.ensureString(record.uid)
    }
  }

  /**
   * Unsafely creates an instance of {@link User} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IUser {
      return new User(record);
  }

  /**
   * Creates a new {@link User} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IUser {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`User.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    User.validateCompatibility(parsed);
    return User.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return User.encode(this);
  }

  public static encode(record: IUser): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    User.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IUser, view: BebopView): number {
    const before = view.length;
    const pos = view.reserveMessageLength();
    const start = view.length;
    if (record.name !== undefined) {
      view.writeByte(1);
      view.writeString(record.name);
    }
    if (record.uid !== undefined) {
      view.writeByte(2);
      view.writeString(record.uid);
    }
    view.writeByte(0);
    const end = view.length;
    view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IUser {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return User.readFrom(view);
  }

  public static readFrom(view: BebopView): IUser {
    let message: IUser = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return new User(message);

        case 1:
          message.name = view.readString();
          break;

        case 2:
          message.uid = view.readString();
          break;

        default:
          view.index = end;
          return new User(message);
      }
    }
  }
}


export enum CommandType {

  Hello = 1,

  SessionCreate = 2,

  SessionJoin = 3,

  SessionInfo = 4,

  SessionGet = 5,

  SongShow = 10,
}


export interface ICommand extends BebopRecord {

  type?: CommandType;

  user?: IUser;

  data?: string;
}

export class Command implements ICommand {
  public type?: CommandType;
  public user?: IUser;
  public data?: string;

  constructor(record: ICommand) {
    this.type = record.type;
    this.user = record.user;
    this.data = record.data;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return Command.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: ICommand): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    Command.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link Command}.
   */
  public static validateCompatibility(record: ICommand): void {
    if (record.type !== undefined) {
      BebopTypeGuard.ensureEnum(record.type, CommandType);
    }
    if (record.user !== undefined) {
      User.validateCompatibility(record.user);
    }
    if (record.data !== undefined) {
      BebopTypeGuard.ensureString(record.data)
    }
  }

  /**
   * Unsafely creates an instance of {@link Command} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): ICommand {
      if (record.user !== undefined) {
        record.user = User.unsafeCast(record.user);
      }
      return new Command(record);
  }

  /**
   * Creates a new {@link Command} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): ICommand {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`Command.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    Command.validateCompatibility(parsed);
    return Command.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return Command.encode(this);
  }

  public static encode(record: ICommand): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    Command.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: ICommand, view: BebopView): number {
    const before = view.length;
    const pos = view.reserveMessageLength();
    const start = view.length;
    if (record.type !== undefined) {
      view.writeByte(1);
      view.writeUint32(record.type);
    }
    if (record.user !== undefined) {
      view.writeByte(2);
      User.encodeInto(record.user, view)
    }
    if (record.data !== undefined) {
      view.writeByte(3);
      view.writeString(record.data);
    }
    view.writeByte(0);
    const end = view.length;
    view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): ICommand {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return Command.readFrom(view);
  }

  public static readFrom(view: BebopView): ICommand {
    let message: ICommand = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return new Command(message);

        case 1:
          message.type = view.readUint32() as CommandType;
          break;

        case 2:
          message.user = User.readFrom(view);
          break;

        case 3:
          message.data = view.readString();
          break;

        default:
          view.index = end;
          return new Command(message);
      }
    }
  }
}

