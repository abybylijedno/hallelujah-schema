//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           3.1.3
//
//
//       bebopc source:
//           https://github.com/betwixt-labs/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
import { BebopView, BebopRuntimeError, BebopJson, BebopTypeGuard } from "bebop";
export var BEBOP_SCHEMA = new Uint8Array([
    3,
    6,
    0,
    0,
    0,
    67,
    111,
    109,
    109,
    97,
    110,
    100,
    84,
    121,
    112,
    101,
    0,
    4,
    0,
    251,
    255,
    255,
    255,
    0,
    4,
    0,
    0,
    0,
    9,
    69,
    82,
    82,
    79,
    82,
    0,
    0,
    1,
    0,
    0,
    0,
    72,
    69,
    76,
    76,
    79,
    0,
    0,
    2,
    0,
    0,
    0,
    83,
    69,
    83,
    83,
    73,
    79,
    78,
    95,
    67,
    82,
    69,
    65,
    84,
    69,
    0,
    0,
    3,
    0,
    0,
    0,
    83,
    69,
    83,
    83,
    73,
    79,
    78,
    95,
    68,
    69,
    76,
    69,
    84,
    69,
    0,
    0,
    4,
    0,
    0,
    0,
    83,
    69,
    83,
    83,
    73,
    79,
    78,
    95,
    74,
    79,
    73,
    78,
    0,
    0,
    5,
    0,
    0,
    0,
    83,
    69,
    83,
    83,
    73,
    79,
    78,
    95,
    76,
    69,
    65,
    86,
    69,
    0,
    0,
    6,
    0,
    0,
    0,
    83,
    69,
    83,
    83,
    73,
    79,
    78,
    95,
    71,
    69,
    84,
    0,
    0,
    7,
    0,
    0,
    0,
    83,
    69,
    83,
    83,
    73,
    79,
    78,
    95,
    73,
    78,
    70,
    79,
    0,
    0,
    8,
    0,
    0,
    0,
    83,
    79,
    78,
    71,
    95,
    86,
    69,
    82,
    83,
    69,
    0,
    0,
    9,
    0,
    0,
    0,
    69,
    114,
    114,
    111,
    114,
    0,
    1,
    0,
    0,
    5,
    0,
    0,
    0,
    0,
    2,
    99,
    111,
    100,
    101,
    0,
    254,
    255,
    255,
    255,
    0,
    109,
    115,
    103,
    0,
    245,
    255,
    255,
    255,
    0,
    85,
    115,
    101,
    114,
    0,
    2,
    0,
    5,
    0,
    0,
    0,
    2,
    110,
    97,
    109,
    101,
    0,
    245,
    255,
    255,
    255,
    0,
    1,
    117,
    105,
    100,
    0,
    245,
    255,
    255,
    255,
    0,
    2,
    83,
    101,
    115,
    115,
    105,
    111,
    110,
    0,
    2,
    0,
    5,
    0,
    0,
    0,
    4,
    105,
    100,
    0,
    245,
    255,
    255,
    255,
    0,
    1,
    110,
    97,
    109,
    101,
    0,
    245,
    255,
    255,
    255,
    0,
    2,
    111,
    119,
    110,
    101,
    114,
    0,
    2,
    0,
    0,
    0,
    0,
    3,
    117,
    115,
    101,
    114,
    115,
    0,
    242,
    255,
    255,
    255,
    0,
    2,
    0,
    0,
    0,
    0,
    4,
    83,
    111,
    110,
    103,
    86,
    101,
    114,
    115,
    101,
    0,
    2,
    0,
    5,
    0,
    0,
    0,
    2,
    115,
    111,
    110,
    103,
    72,
    97,
    115,
    104,
    0,
    245,
    255,
    255,
    255,
    0,
    1,
    118,
    101,
    114,
    115,
    101,
    73,
    100,
    120,
    0,
    254,
    255,
    255,
    255,
    0,
    2,
    67,
    111,
    109,
    109,
    97,
    110,
    100,
    0,
    2,
    0,
    5,
    0,
    0,
    0,
    5,
    116,
    121,
    112,
    101,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    117,
    115,
    101,
    114,
    0,
    2,
    0,
    0,
    0,
    0,
    2,
    101,
    114,
    114,
    111,
    114,
    0,
    1,
    0,
    0,
    0,
    0,
    3,
    115,
    101,
    115,
    115,
    105,
    111,
    110,
    0,
    3,
    0,
    0,
    0,
    0,
    4,
    115,
    111,
    110,
    103,
    86,
    101,
    114,
    115,
    101,
    0,
    4,
    0,
    0,
    0,
    0,
    5,
    0,
    0,
    0,
    0
]);
export var CommandType = /*#__PURE__*/ function(CommandType) {
    CommandType[CommandType["Error"] = 1] = "Error";
    CommandType[CommandType["Hello"] = 2] = "Hello";
    CommandType[CommandType["SessionCreate"] = 3] = "SessionCreate";
    CommandType[CommandType["SessionDelete"] = 4] = "SessionDelete";
    CommandType[CommandType["SessionJoin"] = 5] = "SessionJoin";
    CommandType[CommandType["SessionLeave"] = 6] = "SessionLeave";
    CommandType[CommandType["SessionGet"] = 7] = "SessionGet";
    CommandType[CommandType["SessionInfo"] = 8] = "SessionInfo";
    CommandType[CommandType["SongVerse"] = 9] = "SongVerse";
    return CommandType;
}({});
export var Error = /*#__PURE__*/ function() {
    "use strict";
    function Error(record) {
        _class_call_check(this, Error);
        _define_property(this, "code", void 0);
        _define_property(this, "msg", void 0);
        this.code = record.code;
        this.msg = record.msg;
    }
    _create_class(Error, [
        {
            key: "stringify",
            value: /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */ function stringify() {
                return Error.encodeToJSON(this);
            }
        },
        {
            key: "validateTypes",
            value: /**
   * Validates that the runtime types of members in the current instance are correct.
   */ function validateTypes() {
                Error.validateCompatibility(this);
            }
        },
        {
            key: "encode",
            value: function encode() {
                return Error.encode(this);
            }
        }
    ], [
        {
            key: "encodeToJSON",
            value: /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */ function encodeToJSON(record) {
                return JSON.stringify(record, BebopJson.replacer);
            }
        },
        {
            key: "validateCompatibility",
            value: /**
   * Validates that the specified dynamic object can become an instance of {@link Error}.
   */ function validateCompatibility(record) {
                BebopTypeGuard.ensureUint8(record.code);
                BebopTypeGuard.ensureString(record.msg);
            }
        },
        {
            key: "unsafeCast",
            value: /**
   * Unsafely creates an instance of {@link Error} from the specified dynamic object. No type checking is performed.
   */ function unsafeCast(record) {
                return new Error(record);
            }
        },
        {
            key: "fromJSON",
            value: /**
   * Creates a new {@link Error} instance from a JSON-Over-Bebop string. Type checking is performed.
   */ function fromJSON(json) {
                if (typeof json !== 'string' || json.trim().length === 0) {
                    throw new BebopRuntimeError("Error.fromJSON: expected string");
                }
                var parsed = JSON.parse(json, BebopJson.reviver);
                Error.validateCompatibility(parsed);
                return Error.unsafeCast(parsed);
            }
        },
        {
            key: "encode",
            value: function encode(record) {
                var view = BebopView.getInstance();
                view.startWriting();
                Error.encodeInto(record, view);
                return view.toArray();
            }
        },
        {
            key: "encodeInto",
            value: function encodeInto(record, view) {
                var before = view.length;
                view.writeByte(record.code);
                view.writeString(record.msg);
                var after = view.length;
                return after - before;
            }
        },
        {
            key: "decode",
            value: function decode(buffer) {
                var view = BebopView.getInstance();
                view.startReading(buffer);
                return Error.readFrom(view);
            }
        },
        {
            key: "readFrom",
            value: function readFrom(view) {
                var field0;
                field0 = view.readByte();
                var field1;
                field1 = view.readString();
                var message = {
                    code: field0,
                    msg: field1
                };
                return new Error(message);
            }
        }
    ]);
    return Error;
}();
export var User = /*#__PURE__*/ function() {
    "use strict";
    function User(record) {
        _class_call_check(this, User);
        _define_property(this, "name", void 0);
        _define_property(this, "uid", void 0);
        this.name = record.name;
        this.uid = record.uid;
    }
    _create_class(User, [
        {
            key: "stringify",
            value: /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */ function stringify() {
                return User.encodeToJSON(this);
            }
        },
        {
            key: "validateTypes",
            value: /**
   * Validates that the runtime types of members in the current instance are correct.
   */ function validateTypes() {
                User.validateCompatibility(this);
            }
        },
        {
            key: "encode",
            value: function encode() {
                return User.encode(this);
            }
        }
    ], [
        {
            key: "encodeToJSON",
            value: /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */ function encodeToJSON(record) {
                return JSON.stringify(record, BebopJson.replacer);
            }
        },
        {
            key: "validateCompatibility",
            value: /**
   * Validates that the specified dynamic object can become an instance of {@link User}.
   */ function validateCompatibility(record) {
                if (record.name !== undefined) {
                    BebopTypeGuard.ensureString(record.name);
                }
                if (record.uid !== undefined) {
                    BebopTypeGuard.ensureString(record.uid);
                }
            }
        },
        {
            key: "unsafeCast",
            value: /**
   * Unsafely creates an instance of {@link User} from the specified dynamic object. No type checking is performed.
   */ function unsafeCast(record) {
                return new User(record);
            }
        },
        {
            key: "fromJSON",
            value: /**
   * Creates a new {@link User} instance from a JSON-Over-Bebop string. Type checking is performed.
   */ function fromJSON(json) {
                if (typeof json !== 'string' || json.trim().length === 0) {
                    throw new BebopRuntimeError("User.fromJSON: expected string");
                }
                var parsed = JSON.parse(json, BebopJson.reviver);
                User.validateCompatibility(parsed);
                return User.unsafeCast(parsed);
            }
        },
        {
            key: "encode",
            value: function encode(record) {
                var view = BebopView.getInstance();
                view.startWriting();
                User.encodeInto(record, view);
                return view.toArray();
            }
        },
        {
            key: "encodeInto",
            value: function encodeInto(record, view) {
                var before = view.length;
                var pos = view.reserveMessageLength();
                var start = view.length;
                if (record.name !== undefined) {
                    view.writeByte(1);
                    view.writeString(record.name);
                }
                if (record.uid !== undefined) {
                    view.writeByte(2);
                    view.writeString(record.uid);
                }
                view.writeByte(0);
                var end = view.length;
                view.fillMessageLength(pos, end - start);
                var after = view.length;
                return after - before;
            }
        },
        {
            key: "decode",
            value: function decode(buffer) {
                var view = BebopView.getInstance();
                view.startReading(buffer);
                return User.readFrom(view);
            }
        },
        {
            key: "readFrom",
            value: function readFrom(view) {
                var message = {};
                var length = view.readMessageLength();
                var end = view.index + length;
                while(true){
                    switch(view.readByte()){
                        case 0:
                            return new User(message);
                        case 1:
                            message.name = view.readString();
                            break;
                        case 2:
                            message.uid = view.readString();
                            break;
                        default:
                            view.index = end;
                            return new User(message);
                    }
                }
            }
        }
    ]);
    return User;
}();
export var Session = /*#__PURE__*/ function() {
    "use strict";
    function Session(record) {
        _class_call_check(this, Session);
        _define_property(this, "id", void 0);
        _define_property(this, "name", void 0);
        _define_property(this, "owner", void 0);
        _define_property(this, "users", void 0);
        this.id = record.id;
        this.name = record.name;
        this.owner = record.owner;
        this.users = record.users;
    }
    _create_class(Session, [
        {
            key: "stringify",
            value: /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */ function stringify() {
                return Session.encodeToJSON(this);
            }
        },
        {
            key: "validateTypes",
            value: /**
   * Validates that the runtime types of members in the current instance are correct.
   */ function validateTypes() {
                Session.validateCompatibility(this);
            }
        },
        {
            key: "encode",
            value: function encode() {
                return Session.encode(this);
            }
        }
    ], [
        {
            key: "encodeToJSON",
            value: /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */ function encodeToJSON(record) {
                return JSON.stringify(record, BebopJson.replacer);
            }
        },
        {
            key: "validateCompatibility",
            value: /**
   * Validates that the specified dynamic object can become an instance of {@link Session}.
   */ function validateCompatibility(record) {
                if (record.id !== undefined) {
                    BebopTypeGuard.ensureString(record.id);
                }
                if (record.name !== undefined) {
                    BebopTypeGuard.ensureString(record.name);
                }
                if (record.owner !== undefined) {
                    User.validateCompatibility(record.owner);
                }
                if (record.users !== undefined) {
                    BebopTypeGuard.ensureArray(record.users, User.validateCompatibility);
                }
            }
        },
        {
            key: "unsafeCast",
            value: /**
   * Unsafely creates an instance of {@link Session} from the specified dynamic object. No type checking is performed.
   */ function unsafeCast(record) {
                if (record.owner !== undefined) {
                    record.owner = User.unsafeCast(record.owner);
                }
                return new Session(record);
            }
        },
        {
            key: "fromJSON",
            value: /**
   * Creates a new {@link Session} instance from a JSON-Over-Bebop string. Type checking is performed.
   */ function fromJSON(json) {
                if (typeof json !== 'string' || json.trim().length === 0) {
                    throw new BebopRuntimeError("Session.fromJSON: expected string");
                }
                var parsed = JSON.parse(json, BebopJson.reviver);
                Session.validateCompatibility(parsed);
                return Session.unsafeCast(parsed);
            }
        },
        {
            key: "encode",
            value: function encode(record) {
                var view = BebopView.getInstance();
                view.startWriting();
                Session.encodeInto(record, view);
                return view.toArray();
            }
        },
        {
            key: "encodeInto",
            value: function encodeInto(record, view) {
                var before = view.length;
                var pos = view.reserveMessageLength();
                var start = view.length;
                if (record.id !== undefined) {
                    view.writeByte(1);
                    view.writeString(record.id);
                }
                if (record.name !== undefined) {
                    view.writeByte(2);
                    view.writeString(record.name);
                }
                if (record.owner !== undefined) {
                    view.writeByte(3);
                    User.encodeInto(record.owner, view);
                }
                if (record.users !== undefined) {
                    view.writeByte(4);
                    {
                        var length0 = record.users.length;
                        view.writeUint32(length0);
                        for(var i0 = 0; i0 < length0; i0++){
                            User.encodeInto(record.users[i0], view);
                        }
                    }
                }
                view.writeByte(0);
                var end = view.length;
                view.fillMessageLength(pos, end - start);
                var after = view.length;
                return after - before;
            }
        },
        {
            key: "decode",
            value: function decode(buffer) {
                var view = BebopView.getInstance();
                view.startReading(buffer);
                return Session.readFrom(view);
            }
        },
        {
            key: "readFrom",
            value: function readFrom(view) {
                var message = {};
                var length = view.readMessageLength();
                var end = view.index + length;
                while(true){
                    switch(view.readByte()){
                        case 0:
                            return new Session(message);
                        case 1:
                            message.id = view.readString();
                            break;
                        case 2:
                            message.name = view.readString();
                            break;
                        case 3:
                            message.owner = User.readFrom(view);
                            break;
                        case 4:
                            {
                                var length0 = view.readUint32();
                                message.users = new Array(length0);
                                for(var i0 = 0; i0 < length0; i0++){
                                    var x0 = void 0;
                                    x0 = User.readFrom(view);
                                    message.users[i0] = x0;
                                }
                            }
                            break;
                        default:
                            view.index = end;
                            return new Session(message);
                    }
                }
            }
        }
    ]);
    return Session;
}();
export var SongVerse = /*#__PURE__*/ function() {
    "use strict";
    function SongVerse(record) {
        _class_call_check(this, SongVerse);
        _define_property(this, "songHash", void 0);
        _define_property(this, "verseIdx", void 0);
        this.songHash = record.songHash;
        this.verseIdx = record.verseIdx;
    }
    _create_class(SongVerse, [
        {
            key: "stringify",
            value: /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */ function stringify() {
                return SongVerse.encodeToJSON(this);
            }
        },
        {
            key: "validateTypes",
            value: /**
   * Validates that the runtime types of members in the current instance are correct.
   */ function validateTypes() {
                SongVerse.validateCompatibility(this);
            }
        },
        {
            key: "encode",
            value: function encode() {
                return SongVerse.encode(this);
            }
        }
    ], [
        {
            key: "encodeToJSON",
            value: /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */ function encodeToJSON(record) {
                return JSON.stringify(record, BebopJson.replacer);
            }
        },
        {
            key: "validateCompatibility",
            value: /**
   * Validates that the specified dynamic object can become an instance of {@link SongVerse}.
   */ function validateCompatibility(record) {
                if (record.songHash !== undefined) {
                    BebopTypeGuard.ensureString(record.songHash);
                }
                if (record.verseIdx !== undefined) {
                    BebopTypeGuard.ensureUint8(record.verseIdx);
                }
            }
        },
        {
            key: "unsafeCast",
            value: /**
   * Unsafely creates an instance of {@link SongVerse} from the specified dynamic object. No type checking is performed.
   */ function unsafeCast(record) {
                return new SongVerse(record);
            }
        },
        {
            key: "fromJSON",
            value: /**
   * Creates a new {@link SongVerse} instance from a JSON-Over-Bebop string. Type checking is performed.
   */ function fromJSON(json) {
                if (typeof json !== 'string' || json.trim().length === 0) {
                    throw new BebopRuntimeError("SongVerse.fromJSON: expected string");
                }
                var parsed = JSON.parse(json, BebopJson.reviver);
                SongVerse.validateCompatibility(parsed);
                return SongVerse.unsafeCast(parsed);
            }
        },
        {
            key: "encode",
            value: function encode(record) {
                var view = BebopView.getInstance();
                view.startWriting();
                SongVerse.encodeInto(record, view);
                return view.toArray();
            }
        },
        {
            key: "encodeInto",
            value: function encodeInto(record, view) {
                var before = view.length;
                var pos = view.reserveMessageLength();
                var start = view.length;
                if (record.songHash !== undefined) {
                    view.writeByte(1);
                    view.writeString(record.songHash);
                }
                if (record.verseIdx !== undefined) {
                    view.writeByte(2);
                    view.writeByte(record.verseIdx);
                }
                view.writeByte(0);
                var end = view.length;
                view.fillMessageLength(pos, end - start);
                var after = view.length;
                return after - before;
            }
        },
        {
            key: "decode",
            value: function decode(buffer) {
                var view = BebopView.getInstance();
                view.startReading(buffer);
                return SongVerse.readFrom(view);
            }
        },
        {
            key: "readFrom",
            value: function readFrom(view) {
                var message = {};
                var length = view.readMessageLength();
                var end = view.index + length;
                while(true){
                    switch(view.readByte()){
                        case 0:
                            return new SongVerse(message);
                        case 1:
                            message.songHash = view.readString();
                            break;
                        case 2:
                            message.verseIdx = view.readByte();
                            break;
                        default:
                            view.index = end;
                            return new SongVerse(message);
                    }
                }
            }
        }
    ]);
    return SongVerse;
}();
export var Command = /*#__PURE__*/ function() {
    "use strict";
    function Command(record) {
        _class_call_check(this, Command);
        _define_property(this, "type", void 0);
        _define_property(this, "user", void 0);
        _define_property(this, "error", void 0);
        _define_property(this, "session", void 0);
        _define_property(this, "songVerse", void 0);
        this.type = record.type;
        this.user = record.user;
        this.error = record.error;
        this.session = record.session;
        this.songVerse = record.songVerse;
    }
    _create_class(Command, [
        {
            key: "stringify",
            value: /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */ function stringify() {
                return Command.encodeToJSON(this);
            }
        },
        {
            key: "validateTypes",
            value: /**
   * Validates that the runtime types of members in the current instance are correct.
   */ function validateTypes() {
                Command.validateCompatibility(this);
            }
        },
        {
            key: "encode",
            value: function encode() {
                return Command.encode(this);
            }
        }
    ], [
        {
            key: "encodeToJSON",
            value: /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */ function encodeToJSON(record) {
                return JSON.stringify(record, BebopJson.replacer);
            }
        },
        {
            key: "validateCompatibility",
            value: /**
   * Validates that the specified dynamic object can become an instance of {@link Command}.
   */ function validateCompatibility(record) {
                if (record.type !== undefined) {
                    BebopTypeGuard.ensureEnum(record.type, CommandType);
                }
                if (record.user !== undefined) {
                    User.validateCompatibility(record.user);
                }
                if (record.error !== undefined) {
                    Error.validateCompatibility(record.error);
                }
                if (record.session !== undefined) {
                    Session.validateCompatibility(record.session);
                }
                if (record.songVerse !== undefined) {
                    SongVerse.validateCompatibility(record.songVerse);
                }
            }
        },
        {
            key: "unsafeCast",
            value: /**
   * Unsafely creates an instance of {@link Command} from the specified dynamic object. No type checking is performed.
   */ function unsafeCast(record) {
                if (record.user !== undefined) {
                    record.user = User.unsafeCast(record.user);
                }
                if (record.error !== undefined) {
                    record.error = Error.unsafeCast(record.error);
                }
                if (record.session !== undefined) {
                    record.session = Session.unsafeCast(record.session);
                }
                if (record.songVerse !== undefined) {
                    record.songVerse = SongVerse.unsafeCast(record.songVerse);
                }
                return new Command(record);
            }
        },
        {
            key: "fromJSON",
            value: /**
   * Creates a new {@link Command} instance from a JSON-Over-Bebop string. Type checking is performed.
   */ function fromJSON(json) {
                if (typeof json !== 'string' || json.trim().length === 0) {
                    throw new BebopRuntimeError("Command.fromJSON: expected string");
                }
                var parsed = JSON.parse(json, BebopJson.reviver);
                Command.validateCompatibility(parsed);
                return Command.unsafeCast(parsed);
            }
        },
        {
            key: "encode",
            value: function encode(record) {
                var view = BebopView.getInstance();
                view.startWriting();
                Command.encodeInto(record, view);
                return view.toArray();
            }
        },
        {
            key: "encodeInto",
            value: function encodeInto(record, view) {
                var before = view.length;
                var pos = view.reserveMessageLength();
                var start = view.length;
                if (record.type !== undefined) {
                    view.writeByte(1);
                    view.writeUint32(record.type);
                }
                if (record.user !== undefined) {
                    view.writeByte(2);
                    User.encodeInto(record.user, view);
                }
                if (record.error !== undefined) {
                    view.writeByte(3);
                    Error.encodeInto(record.error, view);
                }
                if (record.session !== undefined) {
                    view.writeByte(4);
                    Session.encodeInto(record.session, view);
                }
                if (record.songVerse !== undefined) {
                    view.writeByte(5);
                    SongVerse.encodeInto(record.songVerse, view);
                }
                view.writeByte(0);
                var end = view.length;
                view.fillMessageLength(pos, end - start);
                var after = view.length;
                return after - before;
            }
        },
        {
            key: "decode",
            value: function decode(buffer) {
                var view = BebopView.getInstance();
                view.startReading(buffer);
                return Command.readFrom(view);
            }
        },
        {
            key: "readFrom",
            value: function readFrom(view) {
                var message = {};
                var length = view.readMessageLength();
                var end = view.index + length;
                while(true){
                    switch(view.readByte()){
                        case 0:
                            return new Command(message);
                        case 1:
                            message.type = view.readUint32();
                            break;
                        case 2:
                            message.user = User.readFrom(view);
                            break;
                        case 3:
                            message.error = Error.readFrom(view);
                            break;
                        case 4:
                            message.session = Session.readFrom(view);
                            break;
                        case 5:
                            message.songVerse = SongVerse.readFrom(view);
                            break;
                        default:
                            view.index = end;
                            return new Command(message);
                    }
                }
            }
        }
    ]);
    return Command;
}();


//# sourceMappingURL=schema.js.map