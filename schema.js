//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           3.1.3
//
//
//       bebopc source:
//           https://github.com/betwixt-labs/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
import { BebopView, BebopRuntimeError, BebopJson, BebopTypeGuard } from "bebop";
export var BEBOP_SCHEMA = new Uint8Array([
    3,
    3,
    0,
    0,
    0,
    85,
    115,
    101,
    114,
    0,
    2,
    0,
    5,
    0,
    0,
    0,
    2,
    110,
    97,
    109,
    101,
    0,
    245,
    255,
    255,
    255,
    0,
    1,
    117,
    105,
    100,
    0,
    245,
    255,
    255,
    255,
    0,
    2,
    67,
    111,
    109,
    109,
    97,
    110,
    100,
    84,
    121,
    112,
    101,
    0,
    4,
    0,
    251,
    255,
    255,
    255,
    0,
    4,
    0,
    0,
    0,
    7,
    69,
    82,
    82,
    79,
    82,
    0,
    0,
    1,
    0,
    0,
    0,
    72,
    69,
    76,
    76,
    79,
    0,
    0,
    2,
    0,
    0,
    0,
    83,
    69,
    83,
    83,
    73,
    79,
    78,
    95,
    67,
    82,
    69,
    65,
    84,
    69,
    0,
    0,
    3,
    0,
    0,
    0,
    83,
    69,
    83,
    83,
    73,
    79,
    78,
    95,
    74,
    79,
    73,
    78,
    0,
    0,
    4,
    0,
    0,
    0,
    83,
    69,
    83,
    83,
    73,
    79,
    78,
    95,
    73,
    78,
    70,
    79,
    0,
    0,
    5,
    0,
    0,
    0,
    83,
    69,
    83,
    83,
    73,
    79,
    78,
    95,
    71,
    69,
    84,
    0,
    0,
    6,
    0,
    0,
    0,
    83,
    79,
    78,
    71,
    95,
    83,
    72,
    79,
    87,
    0,
    0,
    10,
    0,
    0,
    0,
    67,
    111,
    109,
    109,
    97,
    110,
    100,
    0,
    2,
    0,
    5,
    0,
    0,
    0,
    3,
    116,
    121,
    112,
    101,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    117,
    115,
    101,
    114,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    100,
    97,
    116,
    97,
    0,
    245,
    255,
    255,
    255,
    0,
    3,
    0,
    0,
    0,
    0
]);
export var User = /*#__PURE__*/ function() {
    "use strict";
    function User(record) {
        _class_call_check(this, User);
        _define_property(this, "name", void 0);
        _define_property(this, "uid", void 0);
        this.name = record.name;
        this.uid = record.uid;
    }
    _create_class(User, [
        {
            key: "stringify",
            value: /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */ function stringify() {
                return User.encodeToJSON(this);
            }
        },
        {
            key: "validateTypes",
            value: /**
   * Validates that the runtime types of members in the current instance are correct.
   */ function validateTypes() {
                User.validateCompatibility(this);
            }
        },
        {
            key: "encode",
            value: function encode() {
                return User.encode(this);
            }
        }
    ], [
        {
            key: "encodeToJSON",
            value: /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */ function encodeToJSON(record) {
                return JSON.stringify(record, BebopJson.replacer);
            }
        },
        {
            key: "validateCompatibility",
            value: /**
   * Validates that the specified dynamic object can become an instance of {@link User}.
   */ function validateCompatibility(record) {
                if (record.name !== undefined) {
                    BebopTypeGuard.ensureString(record.name);
                }
                if (record.uid !== undefined) {
                    BebopTypeGuard.ensureString(record.uid);
                }
            }
        },
        {
            key: "unsafeCast",
            value: /**
   * Unsafely creates an instance of {@link User} from the specified dynamic object. No type checking is performed.
   */ function unsafeCast(record) {
                return new User(record);
            }
        },
        {
            key: "fromJSON",
            value: /**
   * Creates a new {@link User} instance from a JSON-Over-Bebop string. Type checking is performed.
   */ function fromJSON(json) {
                if (typeof json !== 'string' || json.trim().length === 0) {
                    throw new BebopRuntimeError("User.fromJSON: expected string");
                }
                var parsed = JSON.parse(json, BebopJson.reviver);
                User.validateCompatibility(parsed);
                return User.unsafeCast(parsed);
            }
        },
        {
            key: "encode",
            value: function encode(record) {
                var view = BebopView.getInstance();
                view.startWriting();
                User.encodeInto(record, view);
                return view.toArray();
            }
        },
        {
            key: "encodeInto",
            value: function encodeInto(record, view) {
                var before = view.length;
                var pos = view.reserveMessageLength();
                var start = view.length;
                if (record.name !== undefined) {
                    view.writeByte(1);
                    view.writeString(record.name);
                }
                if (record.uid !== undefined) {
                    view.writeByte(2);
                    view.writeString(record.uid);
                }
                view.writeByte(0);
                var end = view.length;
                view.fillMessageLength(pos, end - start);
                var after = view.length;
                return after - before;
            }
        },
        {
            key: "decode",
            value: function decode(buffer) {
                var view = BebopView.getInstance();
                view.startReading(buffer);
                return User.readFrom(view);
            }
        },
        {
            key: "readFrom",
            value: function readFrom(view) {
                var message = {};
                var length = view.readMessageLength();
                var end = view.index + length;
                while(true){
                    switch(view.readByte()){
                        case 0:
                            return new User(message);
                        case 1:
                            message.name = view.readString();
                            break;
                        case 2:
                            message.uid = view.readString();
                            break;
                        default:
                            view.index = end;
                            return new User(message);
                    }
                }
            }
        }
    ]);
    return User;
}();
export var CommandType = /*#__PURE__*/ function(CommandType) {
    CommandType[CommandType["Error"] = 1] = "Error";
    CommandType[CommandType["Hello"] = 2] = "Hello";
    CommandType[CommandType["SessionCreate"] = 3] = "SessionCreate";
    CommandType[CommandType["SessionJoin"] = 4] = "SessionJoin";
    CommandType[CommandType["SessionInfo"] = 5] = "SessionInfo";
    CommandType[CommandType["SessionGet"] = 6] = "SessionGet";
    CommandType[CommandType["SongShow"] = 10] = "SongShow";
    return CommandType;
}({});
export var Command = /*#__PURE__*/ function() {
    "use strict";
    function Command(record) {
        _class_call_check(this, Command);
        _define_property(this, "type", void 0);
        _define_property(this, "user", void 0);
        _define_property(this, "data", void 0);
        this.type = record.type;
        this.user = record.user;
        this.data = record.data;
    }
    _create_class(Command, [
        {
            key: "stringify",
            value: /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */ function stringify() {
                return Command.encodeToJSON(this);
            }
        },
        {
            key: "validateTypes",
            value: /**
   * Validates that the runtime types of members in the current instance are correct.
   */ function validateTypes() {
                Command.validateCompatibility(this);
            }
        },
        {
            key: "encode",
            value: function encode() {
                return Command.encode(this);
            }
        }
    ], [
        {
            key: "encodeToJSON",
            value: /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */ function encodeToJSON(record) {
                return JSON.stringify(record, BebopJson.replacer);
            }
        },
        {
            key: "validateCompatibility",
            value: /**
   * Validates that the specified dynamic object can become an instance of {@link Command}.
   */ function validateCompatibility(record) {
                if (record.type !== undefined) {
                    BebopTypeGuard.ensureEnum(record.type, CommandType);
                }
                if (record.user !== undefined) {
                    User.validateCompatibility(record.user);
                }
                if (record.data !== undefined) {
                    BebopTypeGuard.ensureString(record.data);
                }
            }
        },
        {
            key: "unsafeCast",
            value: /**
   * Unsafely creates an instance of {@link Command} from the specified dynamic object. No type checking is performed.
   */ function unsafeCast(record) {
                if (record.user !== undefined) {
                    record.user = User.unsafeCast(record.user);
                }
                return new Command(record);
            }
        },
        {
            key: "fromJSON",
            value: /**
   * Creates a new {@link Command} instance from a JSON-Over-Bebop string. Type checking is performed.
   */ function fromJSON(json) {
                if (typeof json !== 'string' || json.trim().length === 0) {
                    throw new BebopRuntimeError("Command.fromJSON: expected string");
                }
                var parsed = JSON.parse(json, BebopJson.reviver);
                Command.validateCompatibility(parsed);
                return Command.unsafeCast(parsed);
            }
        },
        {
            key: "encode",
            value: function encode(record) {
                var view = BebopView.getInstance();
                view.startWriting();
                Command.encodeInto(record, view);
                return view.toArray();
            }
        },
        {
            key: "encodeInto",
            value: function encodeInto(record, view) {
                var before = view.length;
                var pos = view.reserveMessageLength();
                var start = view.length;
                if (record.type !== undefined) {
                    view.writeByte(1);
                    view.writeUint32(record.type);
                }
                if (record.user !== undefined) {
                    view.writeByte(2);
                    User.encodeInto(record.user, view);
                }
                if (record.data !== undefined) {
                    view.writeByte(3);
                    view.writeString(record.data);
                }
                view.writeByte(0);
                var end = view.length;
                view.fillMessageLength(pos, end - start);
                var after = view.length;
                return after - before;
            }
        },
        {
            key: "decode",
            value: function decode(buffer) {
                var view = BebopView.getInstance();
                view.startReading(buffer);
                return Command.readFrom(view);
            }
        },
        {
            key: "readFrom",
            value: function readFrom(view) {
                var message = {};
                var length = view.readMessageLength();
                var end = view.index + length;
                while(true){
                    switch(view.readByte()){
                        case 0:
                            return new Command(message);
                        case 1:
                            message.type = view.readUint32();
                            break;
                        case 2:
                            message.user = User.readFrom(view);
                            break;
                        case 3:
                            message.data = view.readString();
                            break;
                        default:
                            view.index = end;
                            return new Command(message);
                    }
                }
            }
        }
    ]);
    return Command;
}();


//# sourceMappingURL=schema.js.map